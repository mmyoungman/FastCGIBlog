title: Behind the Libraries Part 1 -- Diving into digitalWrite
uri:/behind-the-libraries-diving-into-digitalwrite
author:Mark
date:06-08-2017
body:
<blockquote>void setup() {<br>
&nbsp;&nbsp;pinMode(13, OUTPUT);<br>
}<br>
<br>
void loop() {<br>
&nbsp;&nbsp;digitalWrite(13, HIGH);<br>
&nbsp;&nbsp;delay(1000);<br>
&nbsp;&nbsp;digitalWrite(13, LOW);<br>
&nbsp;&nbsp;delay(1000);<br>
}</blockquote><br>
How does this code make the Arduino Uno’s on-board LED (or an LED connected to pin 13) blink? That was the question I was asking myself after getting the program to work. I was wondering what functions like pinMode and digitalWrite did, how the underlying hardware worked. In this series, that's what I intend to find out. <br>
<br>
The goal of the series is to gain mastery over the Arduino Uno as a piece of hardware, rather than its associated tools and libraries. Sometimes the Arduino libraries and IDE can make accessing the hardware directly more difficult, but I think the availability and convenience of the Arduino Uno and its associated tools overrule these issues. And hopefully, as the series progresses, we'll discover ways to overcome these difficulties. <br>
<br>
I've tried to provide links to further explanation for concepts that I don't explain myself. If I haven't clearly or correctly explained anything, please let me know. I'd welcome any feedback.<br>
<br>
<b>Peaking Behind digitalWrite</b><br>
<br>
When we write "digitalWrite(13, HIGH), essentially all the function does is write a "1" into the specific bit of memory that relates to pin 13. When we set the pin to "LOW", it writes a "0". So, if we know the memory address of the bit that determines whether pin 13 is on or off, we can access it directly instead of using the digitalWrite function.<br>
<br>
On an Arduino Uno, this bit of memory is located on the ATmega328p chip that is essentially the brains of the Arduino. If you look at the biggest chip on your Arduino, you will see the Atmel logo and MEGA328P written on it. As well as producing the chip, Atmel also produce a <a href="http://www.atmel.com/devices/ATMEGA328P.aspx">datasheet</a> for it. It is an exhaustive guide to everything the chip does. Using it, we can learn the address of bit of memory we're looking for.<br>
<br>
By looking at the <a href="https://www.arduino.cc/en/uploads/Main/Arduino_Uno_Rev3-schematic.pdf">Arduino's schematics</a> (or elsewhere), we can discover that pin 13 is connected to the PB5 pin (or PORTB5) of the ATmega328p chip. <br>
<br>
<img src="0001-pin13topb5fromschematic-300x289.png"><br>
<br>
The datasheet (p116) tells us that the bit that controls the output of that pin is found at the address <a href="https://en.wikipedia.org/wiki/0x">0x</a>25. That hexidecimal address points to an 8-bit register, which is essentially a piece of memory that can store eight bits, eight 1’s and 0’s. According to the datasheet, the 5<sup>th</sup> bit stored in the register at address 0x25 controls whether pin 13 is on or off.<br>
<br>
<img src="http://www.theblinkingbreadboard.com/wp-content/uploads/2017/02/0001-PortBDatasheet.png"><br>
<br>
<b>NOTE</b>: While the standard PC contains only one memory space, the ATmega328p actually contains <a href="http://playground.arduino.cc/Learning/Memory">three separate memory spaces</a>. This introduces ambiguity, as the address 0x25 can refer to multiple pieces of memory. When we deference the 0x25 pointer in this case, however, the <a href="https://en.wikipedia.org/wiki/Compiler">compiler</a> gives us access to SRAM, which is what we want.<br>
<br>
We can see from the datasheet the how the eight bits of the register are numbered, with the 0<sup>th</sup> bit being the least significant, and the 7<sup>th</sup> being the final and most significant.<br>
<br>
Unfortunately, if we want to avoid all library use, we have to do the following jiggery pokery to access this register in our code:<br>
<blockquote>*(uint8_t *)0x25</blockquote><br>
The "(uint8_t *)" casts the hexidecimal value 0x25 as an <a href="http://cplus.about.com/od/glossar1/g/unsigneddefn.htm">unsigned</a> 8-bit integer that points to something (i.e. we're saying it is an address). Once we’ve established that 0x25 is an address, the sole "*" before it asks the program to give us access to the memory located at that address -- known as dereferencing a pointer.<br>
<br>
<b>NOTE</b>: There is a more readable way to access registers like this by using predesignated labels. In this case, rather than "*(uint8_t *)0x25", we could have simply wrote "PORTB". <br>
<br>
Now we have access to the 8-bit register and we can change the values of those bits. In C, we can do this with bitwise operators, specifically the &amp; and |, relating to logical AND and OR respectively.<br>
<br>
The <a href="https://en.wikipedia.org/wiki/Bitwise_operations_in_C#Bitwise_AND_.22.26.22">bitwise operations in C</a> page on Wikipedia explains how they work, but the jist is that we can use | to set bits to 1 and &amp; to set bits to 0.<br>
<blockquote>*(uint8_t *)0x25 |= <a href="https://en.wikipedia.org/wiki/0b">0b</a>00100000;</blockquote><br>
This sets the 5<sup>th</sup> bit of the register at address 0x25 to 1, while not changing the other bits. ("A |= B" is equivalent to "A = A | B".)<br>
<blockquote>*(uint8_t *)0x25 &amp;= 0b11011111;</blockquote><br>
This sets the 5<sup>th</sup> bit of the register at address 0x25 to 0, while not changing the other bits.<br>
<br>
Because we know the 5<sup>th</sup> bit in that particular register controls whether pin 13 is on or off, we can use these lines of code and remove digitalWrite from the default blink program.<br>
<blockquote>void setup() {<br>
&nbsp;&nbsp;pinMode(13, OUTPUT);<br>
}<br>
<br>
void loop() {<br>
&nbsp;&nbsp;*(uint8_t *)0x25 |= 0b00100000;<br>
&nbsp;&nbsp;delay(1000);<br>
&nbsp;&nbsp;*(uint8_t *)0x25 &amp;= 0b11011111;<br>
&nbsp;&nbsp;delay(1000);<br>
}</blockquote><br>
If you load this code on to your Arduino, it will work like the default blink program found in File &gt; Examples &gt; 01.Basics.<br>
<br>
<b>NOTE</b>: This isn't a sensible way to write code. We could instead have used "PORTB |= (1 << PORTB5);" and "PORTB &amp;= ~(1 << PORTB5);". That would (arguably) be more readable.<br>
<br>
<b>Turning Other Pins On/Off</b><br>
<br>
Other pins can be turned on or off in the same way. The information to do so can again be found using the <a href="http://www.atmel.com/devices/ATMEGA328P.aspx">datasheet</a> and the <a href="https://www.arduino.cc/en/uploads/Main/Arduino_Uno_Rev3-schematic.pdf">Arduino schematics</a>. Below is the relevant information to save you the search:<br>
<br>
0x25 (the address of PORTB)<br>
<table width="100%" cellspacing="0" cellpadding="4"><colgroup> <col width="29*" /> <col width="29*" /> <col width="28*" /> <col width="28*" /> <col width="28*" /> <col width="28*" /> <col width="28*" /> <col width="28*" /> <col width="28*" /> </colgroup>
<tbody>
<tr valign="top">
<td width="11%"><b>Bit</b></td>
<td width="11%">7</td>
<td width="11%">6</td>
<td width="11%">5</td>
<td width="11%">4</td>
<td width="11%">3</td>
<td width="11%">2</td>
<td width="11%">1</td>
<td width="11%">0</td>
</tr>
<tr valign="top">
<td width="11%"><b>Pin</b></td>
<td width="11%">X</td>
<td width="11%">X</td>
<td width="11%">13</td>
<td width="11%">12</td>
<td width="11%">11</td>
<td width="11%">10</td>
<td width="11%">9</td>
<td width="11%">8</td>
</tr>
</tbody>
</table><br>
0x28 (the address of PORTC)<br>
<table width="100%" cellspacing="0" cellpadding="4"><colgroup> <col width="28*" /> <col width="28*" /> <col width="28*" /> <col width="28*" /> <col width="28*" /> <col width="28*" /> <col width="28*" /> <col width="28*" /> <col width="28*" /> </colgroup>
<tbody>
<tr valign="top">
<td width="11%"><b>Bit</b></td>
<td width="11%">7</td>
<td width="11%">6</td>
<td width="11%">5</td>
<td width="11%">4</td>
<td width="11%">3</td>
<td width="11%">2</td>
<td width="11%">1</td>
<td width="11%">0</td>
</tr>
<tr valign="top">
<td width="11%"><b>Pin</b></td>
<td width="11%">X</td>
<td width="11%">RESET</td>
<td width="11%">A5</td>
<td width="11%">A4</td>
<td width="11%">A3</td>
<td width="11%">A2</td>
<td width="11%">A1</td>
<td width="11%">A0</td>
</tr>
</tbody>
</table><br>
0x2B (the address of PORTD)<br>
<table width="100%" cellspacing="0" cellpadding="4"><colgroup> <col width="28*" /> <col width="28*" /> <col width="28*" /> <col width="28*" /> <col width="28*" /> <col width="28*" /> <col width="28*" /> <col width="28*" /> <col width="28*" /> </colgroup>
<tbody>
<tr valign="top">
<td width="11%">Bit</td>
<td width="11%">7</td>
<td width="11%">6</td>
<td width="11%">5</td>
<td width="11%">4</td>
<td width="11%">3</td>
<td width="11%">2</td>
<td width="11%">1</td>
<td width="11%">0</td>
</tr>
<tr valign="top">
<td width="11%">Pin</td>
<td width="11%">7</td>
<td width="11%">6</td>
<td width="11%">5</td>
<td width="11%">4</td>
<td width="11%">3</td>
<td width="11%">2</td>
<td width="11%">1</td>
<td width="11%">0</td>
</tr>
</tbody>
</table><br>
Using this information you can turn any pin on or off. For example, to turn pin 0 on you would write:<br>
<blockquote>*(uint8_t *)0x2B |= 0b00000001;</blockquote><br>
<br>
Next time we’ll explore how the pinMode function works.<br>
<br>
Sources:<br>
<a href="https://www.youtube.com/channel/UC7uJBXcRdGlDlKIyr6ZbjBw">Robert Paz's Arduino Basics Lectures</a><br>
<a href="http://garretlab.web.fc2.com/en/arduino/inside/index.html">GarretLab's Playing with Arduino Webpage</a><br>